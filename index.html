<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Detecci√≥n de movimiento ‚Äî M√≥vil / PC</title>
  <style>
    :root{--bg:#071221;--card:#0b2130;--accent:#16a34a;--muted:#9fb0c9}
    *{box-sizing:border-box}
    body{margin:0;min-height:100vh;background:linear-gradient(180deg,#03060a 0,#061428 100%);color:#e6eef8;font-family:Inter,system-ui,Roboto,Arial;padding:12px;display:flex;align-items:flex-start;justify-content:center}
    .wrap{width:100%;max-width:980px}
    header{display:flex;flex-direction:column;gap:6px;margin-bottom:10px}
    h1{font-size:18px;margin:0}
    .panel{background:var(--card);border-radius:12px;overflow:hidden;box-shadow:0 8px 40px rgba(2,6,23,.7)}
    .video-area{position:relative;background:#000}
    video{display:block;width:100%;height:auto}
    canvas#overlay{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none}
    .controls{display:flex;flex-wrap:wrap;gap:8px;padding:10px;align-items:center}
    .btn{background:transparent;border:1px solid rgba(255,255,255,.06);padding:8px 10px;border-radius:10px;color:#dfffe0;cursor:pointer}
    .btn.primary{background:linear-gradient(90deg, rgba(20,160,80,.12), transparent);border-color:rgba(20,160,80,.9)}
    select,input[type=range]{background:#071426;border:1px solid rgba(255,255,255,.04);color:#e6eef8;padding:6px;border-radius:8px}
    .status{margin-left:auto;font-size:13px;color:var(--muted)}
    .footer{padding:10px;border-top:1px solid rgba(255,255,255,.02);font-size:13px;color:var(--muted)}
    .row{display:flex;gap:8px;align-items:center}
    label.small{font-size:13px;color:var(--muted)}
    @media (max-width:600px){ .controls{padding:8px} .btn{padding:8px} }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Detecci√≥n de movimiento ‚Äî m√≥vil y PC</h1>
      <div class="small">Cambia c√°mara (frontal/trasera), detecta movimiento por bloques, modo visi√≥n nocturna y simulaci√≥n t√©rmica (mapa de calor). Requiere HTTPS en m√≥vil para c√°mara trasera.</div>
    </header>

    <div class="panel">
      <div class="video-area" id="stage">
        <video id="video" autoplay playsinline muted></video>
        <canvas id="overlay"></canvas>
      </div>

      <div class="controls">
        <button id="startBtn" class="btn primary">Iniciar</button>
        <button id="stopBtn" class="btn">Detener</button>
        <select id="cameraSelect" class="btn"></select>
        <button id="flipBtn" class="btn">üîÑ Voltear</button>

        <div class="row" style="margin-left:6px">
          <label class="small">Sensibilidad</label>
          <input id="sensitivity" type="range" min="5" max="100" value="25">
        </div>

        <div class="row">
          <label class="small">Tama√±o bloque</label>
          <input id="blockSize" type="range" min="4" max="64" value="16">
        </div>

        <button id="motionToggle" class="btn">Movimiento ON</button>
        <button id="nightToggle" class="btn">Visi√≥n nocturna OFF</button>
        <button id="thermalToggle" class="btn">T√©rmica OFF</button>

        <div class="status" id="status">Estado: detenido</div>
      </div>

      <div class="footer">
        <div style="display:flex;align-items:center;gap:8px;">
          <button id="captureBtn" class="btn">Capturar</button>
          <button id="clearBtn" class="btn">Limpiar overlay</button>
          <div style="margin-left:auto">Hotspot threshold: <input id="hotThreshold" type="range" min="150" max="255" value="200"></div>
        </div>
        <div style="margin-top:8px">Nota: la visi√≥n t√©rmica es una simulaci√≥n basada en brillo. Para detecci√≥n real de calor necesitas una c√°mara t√©rmica f√≠sica.</div>
      </div>
    </div>
  </div>

  <!-- C√≥digo JS -->
  <script>
    // Elementos
    const video = document.getElementById('video');
    const overlay = document.getElementById('overlay');
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const flipBtn = document.getElementById('flipBtn');
    const cameraSelect = document.getElementById('cameraSelect');
    const statusEl = document.getElementById('status');
    const motionToggle = document.getElementById('motionToggle');
    const nightToggle = document.getElementById('nightToggle');
    const thermalToggle = document.getElementById('thermalToggle');
    const sensitivityEl = document.getElementById('sensitivity');
    const blockSizeEl = document.getElementById('blockSize');
    const captureBtn = document.getElementById('captureBtn');
    const clearBtn = document.getElementById('clearBtn');
    const hotThresholdEl = document.getElementById('hotThreshold');

    // Offscreen canvas para procesamiento (no mostrado)
    const proc = document.createElement('canvas');
    const pctx = proc.getContext('2d');
    const octx = overlay.getContext('2d');

    let stream = null;
    let devices = [];
    let deviceIndex = 0; // √≠ndice en devices[]
    let running = false;

    // Opciones
    let detectMotion = true;
    let nightVision = false;
    let thermalVision = false;

    // Buffers
    let prevGray = null;

    // Detectar c√°maras disponibles
    async function listCameras(){
      try{
        const list = await navigator.mediaDevices.enumerateDevices();
        devices = list.filter(d=>d.kind==='videoinput');
        cameraSelect.innerHTML = '';
        devices.forEach((d,i)=>{
          const label = d.label || `C√°mara ${i+1}`;
          const opt = document.createElement('option');
          opt.value = d.deviceId;
          opt.textContent = label;
          cameraSelect.appendChild(opt);
        });
        // si no hay etiquetas y no hay permiso, mostrar mensaje
        if (devices.length===0) {
          const opt = document.createElement('option'); opt.textContent='Sin c√°maras detectadas'; cameraSelect.appendChild(opt);
        }
      }catch(e){
        console.warn('No se pudieron listar dispositivos', e);
      }
    }

    // Iniciar c√°mara (por deviceId preferido)
    async function startCamera(deviceId){
      stopCamera();
      const constraints = { video: { width: { ideal: 640 }, height: { ideal: 480 } } };
      if (deviceId) constraints.video.deviceId = { exact: deviceId };
      try{
        stream = await navigator.mediaDevices.getUserMedia(constraints);
        video.srcObject = stream;
        await video.play();
        overlay.width = video.videoWidth || video.clientWidth;
        overlay.height = video.videoHeight || video.clientHeight;
        proc.width = overlay.width; proc.height = overlay.height;
        // seleccionar deviceIndex
        if (devices && devices.length>0) {
          const idx = devices.findIndex(d=>d.deviceId===deviceId);
          if (idx>=0) deviceIndex = idx;
        }
        running = true;
        statusEl.textContent = 'C√°mara activa';
        prevGray = null;
        requestAnimationFrame(loop);
      }catch(err){
        console.error('startCamera error', err);
        statusEl.textContent = 'Error c√°mara: ' + (err.message||err);
      }
    }

    function stopCamera(){
      running = false;
      if (stream){
        stream.getTracks().forEach(t=>t.stop());
        stream = null;
      }
      statusEl.textContent = 'Detenido';
      // limpiar overlay
      octx.clearRect(0,0,overlay.width,overlay.height);
    }

    // Voltear c√°mara (cambiar a siguiente disponible)
    function flipCamera(){
      if (devices.length<=1){
        // intentar usar facingMode fallback
        const currentFacing = (stream && stream.getVideoTracks && stream.getVideoTracks()[0] && stream.getVideoTracks()[0].getSettings().facingMode) || 'unknown';
        // simple restart con facingMode toggled
        const useUser = currentFacing==='user' ? false : true;
        // try restarting with facingMode
        restartWithFacing(useUser ? 'user' : 'environment');
        return;
      }
      deviceIndex = (deviceIndex + 1) % devices.length;
      const id = devices[deviceIndex].deviceId;
      cameraSelect.value = id;
      startCamera(id);
    }

    async function restartWithFacing(mode){
      stopCamera();
      try{
        const c = { video: { facingMode: { exact: mode }, width:{ideal:640}, height:{ideal:480} } };
        stream = await navigator.mediaDevices.getUserMedia(c);
        video.srcObject = stream; await video.play();
        overlay.width = video.videoWidth; overlay.height = video.videoHeight;
        proc.width = overlay.width; proc.height = overlay.height;
        running = true; prevGray = null; requestAnimationFrame(loop);
        statusEl.textContent = 'C√°mara activa ('+mode+')';
      }catch(e){
        console.warn('facingMode error', e);
        statusEl.textContent = 'No se pudo cambiar facingMode';
      }
    }

    // Util: convertir pixel a gris
    function rgbToGray(r,g,b){ return (r*0.299 + g*0.587 + b*0.114)|0; }

    // Mapa de calor simple: valor 0..255 -> color
    function heatColor(v){
      // azul -> cyan -> green -> yellow -> red
      const t = v/255;
      const r = Math.min(255, Math.max(0, 255*(t>0.6 ? (t-0.6)/0.4 : 0)));
      const g = Math.min(255, Math.max(0, 255*(t>0.3 ? (t-0.3)/0.7 : t/0.3)));
      const b = Math.min(255, Math.max(0, 255*(t<0.3 ? (1 - t/0.3) : (t>0.6 ? 0 : (1 - (t-0.3)/0.3)))));
      return [r|0,g|0,b|0];
    }

    // Loop principal de procesamiento
    function loop(){
      if (!running) return;
      if (video.readyState < 2) { requestAnimationFrame(loop); return; }

      // tama√±o de procesamiento (para rendimiento reducimos si muy grande)
      const W = proc.width = Math.max(160, Math.min(640, video.videoWidth));
      const H = proc.height = Math.max(120, Math.min(480, video.videoHeight));

      pctx.drawImage(video, 0, 0, W, H);
      const frame = pctx.getImageData(0,0,W,H);
      const pixels = frame.data;
      const block = parseInt(blockSizeEl.value,10) || 16;
      const sens = parseInt(sensitivityEl.value,10) || 25;
      const hotThreshold = parseInt(hotThresholdEl.value,10) || 200;

      // preparar salida overlay (clear)
      octx.clearRect(0,0,overlay.width,overlay.height);

      // si nightVision o thermal, generamos imagen procesada y la mostramos en overlay
      if (nightVision || thermalVision){
        // crear imagen para overlay
        const out = octx.createImageData(W,H);
        for (let i=0, j=0; i<pixels.length; i+=4, j++){
          const r = pixels[i], g = pixels[i+1], b = pixels[i+2];
          const gray = rgbToGray(r,g,b);
          if (nightVision){
            // aumentar verde y brillo
            const ng = Math.min(255, gray * 1.8);
            out.data[i] = 0;
            out.data[i+1] = ng;
            out.data[i+2] = Math.min(255, gray*0.4);
            out.data[i+3] = 255;
          } else if (thermalVision){
            // mapear gray a color
            const [cr,cg,cb] = heatColor(gray);
            out.data[i] = cr; out.data[i+1]=cg; out.data[i+2]=cb; out.data[i+3]=255;
          }
        }
        // dibujar escala a pantalla (escalamos del tama√±o W,H al tama√±o del canvas overlay)
        // putImageData no escala; as√≠ que usamos un canvas temporal para dibujar y escalar
        const tmp = document.createElement('canvas'); tmp.width=W; tmp.height=H; tmp.getContext('2d').putImageData(out,0,0);
        octx.drawImage(tmp, 0, 0, overlay.width, overlay.height);
      }

      // Movimiento en bloques (si est√° activado)
      if (detectMotion){
        // crear grayscale actual
        const curGray = new Uint8ClampedArray((W*H));
        for (let i=0, p=0; i<pixels.length; i+=4, p++){
          curGray[p] = rgbToGray(pixels[i], pixels[i+1], pixels[i+2]);
        }

        if (prevGray == null) prevGray = curGray;

        const blocksX = Math.ceil(W / block);
        const blocksY = Math.ceil(H / block);

        let totalMotion = 0;

        // recorrer bloques
        for (let by=0; by<blocksY; by++){
          for (let bx=0; bx<blocksX; bx++){
            let sum=0; let count=0;
            const startX = bx*block; const startY = by*block;
            for (let y=startY; y<Math.min(H, startY+block); y++){
              const row = y*W;
              for (let x=startX; x<Math.min(W, startX+block); x++){
                const idx = row + x;
                const d = Math.abs(curGray[idx] - prevGray[idx]);
                sum += d;
                count++;
              }
            }
            const avg = sum / count; // prom diff en bloque
            totalMotion += sum;
            if (avg > sens){
              // dibujar rect en overlay (convertir coordenadas a overlay size)
              const x1 = Math.round((bx*block) * (overlay.width / W));
              const y1 = Math.round((by*block) * (overlay.height / H));
              const w1 = Math.round(block * (overlay.width / W));
              const h1 = Math.round(block * (overlay.height / H));
              octx.strokeStyle = 'rgba(255,200,0,0.9)';
              octx.lineWidth = Math.max(1, (overlay.width/300));
              octx.strokeRect(x1,y1,w1,h1);
              octx.fillStyle = 'rgba(255,200,0,0.12)';
              octx.fillRect(x1,y1,w1,h1);
            }

            // Hotspot detection based on brightness (thermal mode)
            if (thermalVision){
              // promedio brillo del bloque
              const bright = (()=>{
                let bs=0; let bc=0; const sy=startY; const ey=Math.min(H,startY+block);
                for (let yy=sy; yy<ey; yy++){
                  const rrow = yy*W;
                  for (let xx=startX; xx<Math.min(W,startX+block); xx++){
                    bs += curGray[rrow + xx]; bc++;
                  }
                }
                return bs/bc;
              })();
              if (bright > hotThreshold){
                const x1 = Math.round((bx*block) * (overlay.width / W));
                const y1 = Math.round((by*block) * (overlay.height / H));
                const w1 = Math.round(block * (overlay.width / W));
                const h1 = Math.round(block * (overlay.height / H));
                octx.strokeStyle = 'rgba(255,80,80,0.95)';
                octx.lineWidth = Math.max(1, (overlay.width/250));
                octx.strokeRect(x1,y1,w1,h1);
                octx.fillStyle = 'rgba(255,80,80,0.18)';
                octx.fillRect(x1,y1,w1,h1);
                // etiqueta
                octx.fillStyle = 'rgba(255,80,80,0.98)';
                octx.font = `${12 * (overlay.width / 400)}px Arial`;
                octx.fillText('Hot', x1 + 4, y1 + 12);
              }
            }
          }
        }

        // actualizar prev
        prevGray = curGray;

        // mostrar estado global
        const motionDetected = totalMotion > (W*H*0.5); // umbral global aproximado
        if (motionDetected) statusEl.textContent = 'Movimiento detectado'; else statusEl.textContent = 'Sin movimiento';
      }

      requestAnimationFrame(loop);
    }

    // eventos UI
    startBtn.addEventListener('click', async ()=>{
      await listCameras();
      const sel = cameraSelect.value || (devices[0] && devices[0].deviceId);
      await startCamera(sel);
    });
    stopBtn.addEventListener('click', ()=>{ stopCamera(); });
    flipBtn.addEventListener('click', ()=>{ flipCamera(); });
    cameraSelect.addEventListener('change', ()=>{ startCamera(cameraSelect.value); });

    motionToggle.addEventListener('click', ()=>{
      detectMotion = !detectMotion; motionToggle.textContent = detectMotion ? 'Movimiento ON' : 'Movimiento OFF';
      if (!detectMotion) { octx.clearRect(0,0,overlay.width,overlay.height); statusEl.textContent = 'Detecci√≥n de movimiento desactivada'; }
    });
    nightToggle.addEventListener('click', ()=>{ nightVision = !nightVision; if (nightVision) thermalVision=false; nightToggle.textContent = nightVision ? 'Visi√≥n nocturna ON' : 'Visi√≥n nocturna OFF'; });
    thermalToggle.addEventListener('click', ()=>{ thermalVision = !thermalVision; if (thermalVision) nightVision=false; thermalToggle.textContent = thermalVision ? 'T√©rmica ON' : 'T√©rmica OFF'; });

    captureBtn.addEventListener('click', ()=>{
      // capturar imagen con overlay
      const out = document.createElement('canvas'); out.width = overlay.width; out.height = overlay.height; const oc = out.getContext('2d');
      oc.drawImage(video,0,0,out.width,out.height);
      oc.drawImage(overlay,0,0,out.width,out.height);
      const url = out.toDataURL('image/png'); window.open(url,'_blank');
    });

    clearBtn.addEventListener('click', ()=>{ octx.clearRect(0,0,overlay.width,overlay.height); });

    // al cargar la p√°gina, intentar listar c√°maras
    (async ()=>{
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        statusEl.textContent = 'Tu navegador no soporta getUserMedia.'; return;
      }
      await listCameras();
      // si hay c√°maras y el usuario ya dio permiso, las labels aparecer√°n; en caso contrario pedir permiso al iniciar.
    })();

    // prevenir que la pantalla se duerma en m√≥vil (opcional API Screen Wake Lock) - no obligatorio
    let wakeLock = null;
    async function requestWakeLock(){
      try{ if ('wakeLock' in navigator) wakeLock = await navigator.wakeLock.request('screen'); }catch(e){}
    }
    // solicitar wake lock al iniciar c√°mara
    startBtn.addEventListener('click', ()=>{ requestWakeLock(); });

  </script>
</body>
</html>
